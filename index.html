<!DOCTYPE html>
<html>
<head>
    <title>Flag Quiz Online</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        /* ... Your complete CSS styles are here ... */
    </style>
</head>

<header style="padding: 10px; border-bottom: 1px solid #ccc;">
    <span id="welcome-message">Welcome, Guest!</span> 
    <a href="/logout" style="float: right; color: red;">Logout</a>
</header>
<body>

<div id="game-container">
    
    </div>

<script src="/socket.io/socket.io.js"></script>

<script>
    // --- AUTHENTICATION START ---
    
    // Helper function to get URL parameters
    function getQueryParameter(name) {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get(name);
    }

    const userId = getQueryParameter('userId');

    // 1. Check for Authentication
    if (!userId) {
        // If the userId is missing, redirect the user to login page
        alert("Please log in to play the game.");
        window.location.href = '/login';
        // Stop script execution
        throw new Error("Unauthenticated access."); 
    }

    // 2. Dynamic Socket Connection (required for Render)
    // Get the base URL (e.g., https://your-render-app.onrender.com)
    const RENDER_URL = window.location.protocol + "//" + window.location.host;

    // Connect, passing the userId in the query parameter
    const socket = io(RENDER_URL, {
        query: {
            userId: userId // Sends the ID to the server's handshake
        }
    });

    // 3. Socket Listeners for Auth
    socket.on('connect', () => {
        // Hide userId from the URL after successful connection
        history.replaceState(null, '', window.location.pathname); 
        
        statusEl.textContent = '‚úÖ Connected. Authenticating...';
        statusEl.style.color = getCssVar('--text-color');
        resetUI(false);
    });

    socket.on('auth_successful', (data) => {
        // Server confirmed the ID is valid and sent the username
        document.getElementById('welcome-message').textContent = `Welcome, ${data.username}!`;
        console.log(`Authenticated as ${data.username}. Searching for an opponent...`);
        
        // Now proceed to the main matchmaking status
        statusEl.textContent = '‚è±Ô∏è Searching for opponent...';
        statusEl.style.color = getCssVar('--text-color');
    });

    socket.on('unauthorized_access', () => {
        // Fallback if the server specifically rejects the userId
        alert("Authentication failed. Redirecting to login.");
        window.location.href = '/login';
    });

    // --- END AUTHENTICATION ---


    let currentMatchId = null;
    let isAnswered = false;
    let roundStartTime = 0; 
    let myScore = 0;
    let opponentScore = 0;
    let isP1 = false; 

    // --- ELEMENT REFERENCES (No change, but ensuring they are below the auth logic) ---
    // Using window.onload or DOMContentLoaded is safer for fetching these, 
    // but since the script is at the end of the body, it should be fine.
    const gameContainerEl = document.getElementById('game-container');
    const statusEl = document.getElementById('status');
    const roundDisplayEl = document.getElementById('round-display');
    const flagImageEl = document.getElementById('current-flag');
    const optionsContainerEl = document.getElementById('options-container');
    const resultMessageEl = document.getElementById('result-message');
    let playerScoreEl = document.getElementById('player-score'); 
    let opponentScoreEl = document.getElementById('opponent-score'); 
    const playerTimeEl = document.getElementById('player-time');
    const opponentTimeEl = document.getElementById('opponent-time');
    const scoreboardContainerEl = document.getElementById('scoreboard-container');
    
    // Helper to get CSS variables
    function getCssVar(name) {
        return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
    }


    // --- VISUAL/STATE MANAGEMENT (Minor Fixes) ---

    function resetUI(showRoundDisplay = true) {
        // ... (Your existing resetUI logic) ...
        optionsContainerEl.innerHTML = '';
        flagImageEl.src = 'data:image/gif;base64,R0GODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'; 
        resultMessageEl.textContent = '';
        playerTimeEl.textContent = 'YOU: --';
        opponentTimeEl.textContent = 'OPPONENT: --';
        
        scoreboardContainerEl.classList.remove('final-board');
        
        const finalMessage = document.getElementById('final-score-message');
        if (finalMessage) {
            finalMessage.remove();
        }
        
        const titleEl = document.querySelector('h1');
        
        // Hide elements that aren't needed when waiting
        const elementsToToggle = [roundDisplayEl, flagImageEl, optionsContainerEl, resultMessageEl, playerTimeEl.parentElement, scoreboardContainerEl];
        
        elementsToToggle.forEach(el => {
            el.style.display = showRoundDisplay ? (el.id === 'options-container' ? 'flex' : 'block') : 'none';
        });

        // H1 and status are always visible (except when game is active for H1)
        titleEl.style.display = showRoundDisplay ? 'none' : 'flex';
        statusEl.style.display = 'flex'; // Status should always be visible when waiting
        
        // --- CRITICAL ALIGNMENT CHANGE ---
        if (showRoundDisplay) {
            gameContainerEl.classList.remove('centered-status');
        } else {
            gameContainerEl.classList.add('centered-status');
        }
        // ***********************
    }
    
    // --- SOCKET LISTENERS (Removed 'connect' logic that is now in Auth section) ---
    
    // socket.on('connect' logic is now handled above for authentication status

    socket.on('waiting_for_opponent', () => {
        statusEl.textContent = '‚è±Ô∏è Searching for opponent...';
        statusEl.style.color = getCssVar('--text-color');
        resetUI(false);
    });

    socket.on('match_found', (data) => {
        currentMatchId = data.matchId;
        isP1 = data.isP1; 
        statusEl.textContent = 'ü§ù Match Found! Getting ready...';
        
        myScore = 0;
        opponentScore = 0;
        playerScoreEl.textContent = myScore;
        opponentScoreEl.textContent = opponentScore;
        
        setTimeout(() => {
            statusEl.textContent = ''; // Clear status just before round starts
        }, 1500); 
    });
    
    // ... (rest of your existing socket.on('new_round') logic is fine) ...

    socket.on('new_round', (data) => {
        // ******* CRITICAL FIX: Ensure the round scoreboard structure is restored *******
        // Restore elements that might have been overwritten by endGame()
        document.getElementById('player-score-container').innerHTML = `
            <span id="player-score">${myScore}</span>
            <span class="label">YOU</span>
        `;
        document.getElementById('opponent-score-container').innerHTML = `
            <span id="opponent-score">${opponentScore}</span>
            <span class="label">OPPONENT</span>
        `;
        
        // Re-assign element references after innerHTML changes
        playerScoreEl = document.getElementById('player-score');
        opponentScoreEl = document.getElementById('opponent-score');
        
        // ... (rest of new_round logic is fine) ...
        isAnswered = false;
        resetUI(true); // Show quiz elements
        
        roundStartTime = Date.now(); 
        
        statusEl.textContent = 'Go!';
        statusEl.style.color = getCssVar('--text-color');
        roundDisplayEl.textContent = `‚ñ∂Ô∏è Round ${data.round}`;
        flagImageEl.src = data.image;

        // Reset button colors and enable them
        optionsContainerEl.querySelectorAll('.option-button').forEach(btn => {
            btn.classList.remove('correct', 'incorrect', 'selected');
            btn.disabled = false;
        });
        
        // Populate options
        data.options.forEach(optionText => {
            const button = document.createElement('button');
            button.className = 'option-button';
            button.textContent = optionText;
            button.onclick = () => handleAnswer(optionText, button);
            optionsContainerEl.appendChild(button);
        });
        
        resultMessageEl.textContent = 'Select the correct country!';
        resultMessageEl.style.color = getCssVar('--text-color');
    });

    // ... (rest of your existing socket.on('answer_registered') logic is fine) ...

    // ... (rest of your existing socket.on('round_results') logic is fine) ...

    socket.on('game_over', (data) => {
        // ... (Your existing game_over logic) ...
        
        statusEl.style.display = 'flex';
        roundDisplayEl.style.display = 'none';
        flagImageEl.style.display = 'none';
        optionsContainerEl.style.display = 'none';
        resultMessageEl.style.display = 'none';
        playerTimeEl.parentElement.style.display = 'none';
        
        gameContainerEl.classList.add('centered-status'); // Center the final result
        
        // --- 1. Determine Winner and Message ---
        const myId = socket.id;
        const winnerId = data.winner;
        let message = '';
        let color = getCssVar('--text-color');

        if (winnerId === myId) {
            message = 'üëë YOU WIN! Congratulations!';
            color = getCssVar('--success-color');
        } else if (winnerId) {
            message = 'üíî GAME OVER. Opponent Wins.';
            color = getCssVar('--player-2-color');
        } else {
            message = 'ü§ù It\'s a DRAW!';
            color = getCssVar('--primary-color');
        }

        statusEl.textContent = message;
        statusEl.style.color = color;

        // --- 2. Update Scoreboard to Final Mode ---
        scoreboardContainerEl.classList.add('final-board');
        scoreboardContainerEl.style.display = 'flex'; // Ensure scoreboard is visible

        const localScore = isP1 ? data.p1Score : data.p2Score;
        const oppScore = isP1 ? data.p2Score : data.p1Score;

        // Create the final score message element *before* modifying the scoreboard innerHTML
        const finalScoreMessageEl = document.createElement('p');
        finalScoreMessageEl.id = 'final-score-message';
        finalScoreMessageEl.textContent = `FINAL SCORE: ${localScore} - ${oppScore}`;
        scoreboardContainerEl.insertAdjacentElement('beforebegin', finalScoreMessageEl);


        document.getElementById('player-score-container').innerHTML = `
            <div class="player-name"><span class="color-box" id="player-color-box"></span>YOU</div>
            <span id="player-score">${localScore}</span>
        `;
        document.getElementById('opponent-score-container').innerHTML = `
            <div class="player-name"><span class="color-box" id="opponent-color-box"></span>OPPONENT</div>
            <span id="opponent-score">${oppScore}</span>
        `;

        // --- 3. Play Again Button ---
        const playAgainButton = document.createElement('button');
        playAgainButton.className = 'option-button'; // Reusing styling
        playAgainButton.style.width = '80%';
        playAgainButton.style.marginTop = '2vh';
        playAgainButton.textContent = 'Play Again (Find New Match)';
        playAgainButton.onclick = () => {
            // Re-authenticate (since the socket will be disconnected/reused)
            window.location.reload(); 
        };
        
        // Append the button below the final scoreboard container
        scoreboardContainerEl.insertAdjacentElement('afterend', playAgainButton);

        currentMatchId = null;
    });

    // ... (rest of your existing handleAnswer logic is fine) ...
    function handleAnswer(answerText, button) {
        if (isAnswered) return;
        isAnswered = true;

        // Disable all buttons and mark selected one
        optionsContainerEl.querySelectorAll('.option-button').forEach(btn => btn.disabled = true);
        button.classList.add('selected');

        // Estimate time taken from client perspective (used for display, server time is definitive)
        const timeTaken = (Date.now() - roundStartTime) / 1000;
        playerTimeEl.textContent = `YOU: ${timeTaken.toFixed(2)}s (Submitting...)`;

        // Send the answer to the server
        socket.emit('submit_answer', {
            matchId: currentMatchId,
            answer: answerText
        });
    }

</script>
</html>
